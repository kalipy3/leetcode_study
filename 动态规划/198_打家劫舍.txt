198_打家劫舍.txt
:Author: kalipy
:Email: kalipy@debian
:Date: 2020-09-28 22:29


题目：
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。



示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：

输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。



提示：

    0 <= nums.length <= 100
    0 <= nums[i] <= 400

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/house-robber
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



参考答案：
今天的打卡题目似曾相识呢，没错，我们在两个月前做过一道一样的打卡题 面试题 17.16. 按摩师

所以，如何两个月 0 基础从按摩师转型自由职业者，你差的就是一个入门 DP 的距离！

==============

读题知输入一个长度为 n 的数组，表示 n 个房屋，让我们求到第 n 个房屋的最大金额。

我们想一下到第n个房屋的最大金额 dp[n]: 1. 如果偷第 n 个房屋的话，由于相邻的房屋不能偷，所以 dp[n] = dp[n - 2] + nums[n]（即等于到第 n - 2 个房屋的最大金额 + 第 n 个房屋的金额） 2. 反之如果不偷第 n 个房屋的话，那么 dp[n] = dp[n - 1]（即等于到第 n - 1 个房屋的最大金额）

于是，我们得到了状态转移方程：dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])

==============

一、首先实现一个便于理解的基础版本的 dp, 时间 O(N), 空间 O(N)。

class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        // 处理边界条件。
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return nums[0];
        }
        // 定义dp数组，按照状态转移方程递推。
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);
        }
        return dp[n - 1];
    }
}

ok，就是这么简单，但此时我们发现了一个问题，i 其实只依赖于 i - 1 和 i - 2 两个状态，因此我们其实不需要定义一个长度为 n 的 dp 数组，只要定义两个变量来存储 i - 1 和 i - 2 不就行了嘛，于是这样就把空间优化到了 O(1) ～

二、因此，实现一版空间优化到 O(1) 的代码。

还是参照着 dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]) 这个方程来写，

用 a 表示 i - 2，b 表示 i - 1，

因此上面的方程变成了dp[i] = max(b, a + nums[i])，

然后下一轮循环的时候： i - 1 就变成了i - 2，因此现在需要把 b 赋值给 a； i 就变成了 i - 1，因此现在需要把 dp[i] 赋值给 b。

class Solution {
    public int rob(int[] nums) {
        int a = 0, b = 0;
        for (int i = 0; i < nums.length; i++) {
            int c = Math.max(b, a + nums[i]);
            a = b;
            b = c;
        }
        return b;
    }
}

